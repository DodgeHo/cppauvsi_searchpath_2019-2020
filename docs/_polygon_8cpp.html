<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Search Grid: Polygon.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Search Grid
   </div>
   <div id="projectbrief">AUVSI Search Path Algorithm 2019-2021</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Polygon.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="struct_polygon.html" title="Represents a polygon as a list of vertices in CCW order.">Polygon</a> decomposition and traversal algorithm structs and functions. Implements the greedy recursive approach using minimum width sum outlined in a paper by Yan Li et al. All units are in meters.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;cmath&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;list&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
<code>#include &lt;fstream&gt;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;cfloat&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &quot;<a class="el" href="_graph_8cpp.html">Graph.cpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_config_8h_source.html">Config.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_coord.html">Coord</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple representation of a 2D coordinate.  <a href="struct_coord.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_edge.html">Edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple representation of an edge.  <a href="struct_edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_span.html">Span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a span in Vertex-Edge form.  <a href="struct_span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_polygon.html">Polygon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a polygon as a list of vertices in CCW order.  <a href="struct_polygon.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_node.html" title="Node class for weighted graph. Consists of the search path for the polygon, a pointer to the polygon,...">Node</a> class for weighted graph. Consists of the search path for the polygon, a pointer to the polygon, and the start state.  <a href="struct_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_comp.html">Comp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a598a3330b3c21701223ee0ca14316eca"><td class="memItemLeft" align="right" valign="top"><a id="a598a3330b3c21701223ee0ca14316eca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_polygon_8cpp.html#a598a3330b3c21701223ee0ca14316eca">PI</a>&#160;&#160;&#160;3.14159265358979323846</td></tr>
<tr class="memdesc:a598a3330b3c21701223ee0ca14316eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate value for pi. <br /></td></tr>
<tr class="separator:a598a3330b3c21701223ee0ca14316eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c2040f25d8e3a7b9e1c2024c618cb6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_polygon_8cpp.html#a12c2040f25d8e3a7b9e1c2024c618cb6">INF</a>&#160;&#160;&#160;1000000</td></tr>
<tr class="memdesc:a12c2040f25d8e3a7b9e1c2024c618cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">An effective infinity that will not overflow the float type.  <a href="_polygon_8cpp.html#a12c2040f25d8e3a7b9e1c2024c618cb6">More...</a><br /></td></tr>
<tr class="separator:a12c2040f25d8e3a7b9e1c2024c618cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a5d74787dedbc4e11c1ab15bf487e61f8"><td class="memItemLeft" align="right" valign="top"><a id="a5d74787dedbc4e11c1ab15bf487e61f8"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_polygon_8cpp.html#a5d74787dedbc4e11c1ab15bf487e61f8">State</a> { <b>START_V1</b>, 
<b>START_V2</b>, 
<b>END_V1</b>, 
<b>END_V2</b>
 }</td></tr>
<tr class="memdesc:a5d74787dedbc4e11c1ab15bf487e61f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">State representing which vertex we start the path from. START_V1 = start at vertex 1 of starting edge START_V2 = start at vertex 2 of starting edge END_V1 = start at vertex 1 of end edge END_V2 = start at vertex 2 of end edge. <br /></td></tr>
<tr class="separator:a5d74787dedbc4e11c1ab15bf487e61f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a95a2b3b474c41d8c0cb3b9dcef55da51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_config_8h.html#a25d00a4a2950431bf70b51adcc7cb430">float_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_polygon_8cpp.html#a95a2b3b474c41d8c0cb3b9dcef55da51">distance</a> (const <a class="el" href="struct_coord.html">Coord</a> &amp;v1, const <a class="el" href="struct_coord.html">Coord</a> &amp;v2)</td></tr>
<tr class="memdesc:a95a2b3b474c41d8c0cb3b9dcef55da51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the distance between two vertices.  <a href="_polygon_8cpp.html#a95a2b3b474c41d8c0cb3b9dcef55da51">More...</a><br /></td></tr>
<tr class="separator:a95a2b3b474c41d8c0cb3b9dcef55da51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42102455a1869c5308619ec870c161b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_config_8h.html#a25d00a4a2950431bf70b51adcc7cb430">float_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_polygon_8cpp.html#af42102455a1869c5308619ec870c161b">distance</a> (const <a class="el" href="struct_coord.html">Coord</a> &amp;v, const <a class="el" href="struct_edge.html">Edge</a> &amp;e)</td></tr>
<tr class="memdesc:af42102455a1869c5308619ec870c161b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the distance between a vertex and an edge.  <a href="_polygon_8cpp.html#af42102455a1869c5308619ec870c161b">More...</a><br /></td></tr>
<tr class="separator:af42102455a1869c5308619ec870c161b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c0488ba30bc2473cdea0033bb208aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_span.html">Span</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_polygon_8cpp.html#a52c0488ba30bc2473cdea0033bb208aa">getWidth</a> (const <a class="el" href="struct_polygon.html">Polygon</a> &amp;p)</td></tr>
<tr class="memdesc:a52c0488ba30bc2473cdea0033bb208aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the width of a convex polygon.  <a href="_polygon_8cpp.html#a52c0488ba30bc2473cdea0033bb208aa">More...</a><br /></td></tr>
<tr class="separator:a52c0488ba30bc2473cdea0033bb208aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba208fdf3e27f0a340f19037e1170627"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_polygon_8cpp.html#aba208fdf3e27f0a340f19037e1170627">isConcave</a> (const <a class="el" href="struct_polygon.html">Polygon</a> &amp;p, int i)</td></tr>
<tr class="memdesc:aba208fdf3e27f0a340f19037e1170627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a given vertex of a polygon is concave.  <a href="_polygon_8cpp.html#aba208fdf3e27f0a340f19037e1170627">More...</a><br /></td></tr>
<tr class="separator:aba208fdf3e27f0a340f19037e1170627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac751ca91c162e32134a7878cf1978a1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_polygon_8cpp.html#ac751ca91c162e32134a7878cf1978a1e">split</a> (const <a class="el" href="struct_polygon.html">Polygon</a> &amp;p, int v1, int v2, <a class="el" href="struct_polygon.html">Polygon</a> &amp;p1, <a class="el" href="struct_polygon.html">Polygon</a> &amp;p2)</td></tr>
<tr class="memdesc:ac751ca91c162e32134a7878cf1978a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a polygon into two along an edge.  <a href="_polygon_8cpp.html#ac751ca91c162e32134a7878cf1978a1e">More...</a><br /></td></tr>
<tr class="separator:ac751ca91c162e32134a7878cf1978a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7e7e0da2580bb7f44c59b8bc711ebe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_polygon_8cpp.html#a5d7e7e0da2580bb7f44c59b8bc711ebe">decompose</a> (const <a class="el" href="struct_polygon.html">Polygon</a> &amp;p, std::list&lt; <a class="el" href="struct_polygon.html">Polygon</a> &gt; &amp;l)</td></tr>
<tr class="memdesc:a5d7e7e0da2580bb7f44c59b8bc711ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a concave polygon into multiple convex polygons.  <a href="_polygon_8cpp.html#a5d7e7e0da2580bb7f44c59b8bc711ebe">More...</a><br /></td></tr>
<tr class="separator:a5d7e7e0da2580bb7f44c59b8bc711ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8d432590706d11d55e8be081c39fa4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_polygon.html">Polygon</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_polygon_8cpp.html#abd8d432590706d11d55e8be081c39fa4">merge</a> (const <a class="el" href="struct_polygon.html">Polygon</a> &amp;p1, const <a class="el" href="struct_polygon.html">Polygon</a> &amp;p2, unsigned int i, unsigned int j)</td></tr>
<tr class="memdesc:abd8d432590706d11d55e8be081c39fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge two polygons by their shared edge given the edge's index in each polygon and return the result.  <a href="_polygon_8cpp.html#abd8d432590706d11d55e8be081c39fa4">More...</a><br /></td></tr>
<tr class="separator:abd8d432590706d11d55e8be081c39fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e30299d43abe13ee0c892472f3e3fae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_polygon_8cpp.html#a5e30299d43abe13ee0c892472f3e3fae">mergeSubregions</a> (std::list&lt; <a class="el" href="struct_polygon.html">Polygon</a> &gt; &amp;l)</td></tr>
<tr class="memdesc:a5e30299d43abe13ee0c892472f3e3fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine applicable subregions after decomposition.  <a href="_polygon_8cpp.html#a5e30299d43abe13ee0c892472f3e3fae">More...</a><br /></td></tr>
<tr class="separator:a5e30299d43abe13ee0c892472f3e3fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e70bd36f60e1f3203b1199882b452b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_config_8h.html#a25d00a4a2950431bf70b51adcc7cb430">float_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_polygon_8cpp.html#a8e70bd36f60e1f3203b1199882b452b1">cross</a> (const <a class="el" href="struct_coord.html">Coord</a> &amp;c1, const <a class="el" href="struct_coord.html">Coord</a> &amp;c2)</td></tr>
<tr class="memdesc:a8e70bd36f60e1f3203b1199882b452b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the cross product of two vectors represented as coordinates.  <a href="_polygon_8cpp.html#a8e70bd36f60e1f3203b1199882b452b1">More...</a><br /></td></tr>
<tr class="separator:a8e70bd36f60e1f3203b1199882b452b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc544bfbb4b347cf1ee76da14ab71919"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_polygon_8cpp.html#adc544bfbb4b347cf1ee76da14ab71919">intersection</a> (const <a class="el" href="struct_edge.html">Edge</a> &amp;e1, const <a class="el" href="struct_edge.html">Edge</a> &amp;e2, <a class="el" href="struct_coord.html">Coord</a> &amp;intersect)</td></tr>
<tr class="memdesc:adc544bfbb4b347cf1ee76da14ab71919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the intersection of two line segments.  <a href="_polygon_8cpp.html#adc544bfbb4b347cf1ee76da14ab71919">More...</a><br /></td></tr>
<tr class="separator:adc544bfbb4b347cf1ee76da14ab71919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501f5a6e2cabc73bdc4bfa3340383d78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_polygon_8cpp.html#a501f5a6e2cabc73bdc4bfa3340383d78">traverse</a> (const <a class="el" href="struct_polygon.html">Polygon</a> &amp;p, std::list&lt; <a class="el" href="struct_edge.html">Edge</a> &gt; &amp;waypoints)</td></tr>
<tr class="memdesc:a501f5a6e2cabc73bdc4bfa3340383d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse a convex polygon and store the waypoints in a list as Edges.  <a href="_polygon_8cpp.html#a501f5a6e2cabc73bdc4bfa3340383d78">More...</a><br /></td></tr>
<tr class="separator:a501f5a6e2cabc73bdc4bfa3340383d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03f8a8cabc1677521129dd892c0c8f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_polygon_8cpp.html#ad03f8a8cabc1677521129dd892c0c8f9">computeGraph</a> (<a class="el" href="struct_graph.html">Graph</a>&lt; <a class="el" href="struct_node.html">Node</a>, <a class="el" href="_config_8h.html#a25d00a4a2950431bf70b51adcc7cb430">float_type</a> &gt; &amp;g)</td></tr>
<tr class="memdesc:ad03f8a8cabc1677521129dd892c0c8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to compute the adjacencies and weights of the graph.  <a href="_polygon_8cpp.html#ad03f8a8cabc1677521129dd892c0c8f9">More...</a><br /></td></tr>
<tr class="separator:ad03f8a8cabc1677521129dd892c0c8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8599468fedd0f0707a9fa58b422beab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_config_8h.html#a25d00a4a2950431bf70b51adcc7cb430">float_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_polygon_8cpp.html#ab8599468fedd0f0707a9fa58b422beab">traversalLength</a> (const <a class="el" href="struct_graph.html">Graph</a>&lt; <a class="el" href="struct_node.html">Node</a>, <a class="el" href="_config_8h.html#a25d00a4a2950431bf70b51adcc7cb430">float_type</a> &gt; &amp;g, std::list&lt; unsigned int &gt; &amp;path)</td></tr>
<tr class="memdesc:ab8599468fedd0f0707a9fa58b422beab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the total length of a graph traversal.  <a href="_polygon_8cpp.html#ab8599468fedd0f0707a9fa58b422beab">More...</a><br /></td></tr>
<tr class="separator:ab8599468fedd0f0707a9fa58b422beab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32585f07b1ef2d1350a3c87da3020097"><td class="memItemLeft" align="right" valign="top">std::list&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_polygon_8cpp.html#a32585f07b1ef2d1350a3c87da3020097">minTraversal</a> (<a class="el" href="struct_graph.html">Graph</a>&lt; <a class="el" href="struct_node.html">Node</a>, <a class="el" href="_config_8h.html#a25d00a4a2950431bf70b51adcc7cb430">float_type</a> &gt; &amp;g)</td></tr>
<tr class="memdesc:a32585f07b1ef2d1350a3c87da3020097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the minimum cost traversal for the weighted graph.  <a href="_polygon_8cpp.html#a32585f07b1ef2d1350a3c87da3020097">More...</a><br /></td></tr>
<tr class="separator:a32585f07b1ef2d1350a3c87da3020097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32400b851831f6e0cd8f1f52ba98fc5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_polygon_8cpp.html#a32400b851831f6e0cd8f1f52ba98fc5e">computeStates</a> (std::list&lt; unsigned int &gt; &amp;path, <a class="el" href="struct_graph.html">Graph</a>&lt; <a class="el" href="struct_node.html">Node</a>, <a class="el" href="_config_8h.html#a25d00a4a2950431bf70b51adcc7cb430">float_type</a> &gt; &amp;g)</td></tr>
<tr class="memdesc:a32400b851831f6e0cd8f1f52ba98fc5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the start states of each node along the traversal.  <a href="_polygon_8cpp.html#a32400b851831f6e0cd8f1f52ba98fc5e">More...</a><br /></td></tr>
<tr class="separator:a32400b851831f6e0cd8f1f52ba98fc5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79821244b87f1fef961a2665b18181f9"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="struct_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_polygon_8cpp.html#a79821244b87f1fef961a2665b18181f9">searchPath</a> (const <a class="el" href="struct_polygon.html">Polygon</a> &amp;p)</td></tr>
<tr class="memdesc:a79821244b87f1fef961a2665b18181f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the search path for a polygon.  <a href="_polygon_8cpp.html#a79821244b87f1fef961a2665b18181f9">More...</a><br /></td></tr>
<tr class="separator:a79821244b87f1fef961a2665b18181f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5576f119ecbff102d8abea775f348f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_polygon_8cpp.html#a4f5576f119ecbff102d8abea775f348f">clockwise</a> (const std::vector&lt; <a class="el" href="struct_coord.html">Coord</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:a4f5576f119ecbff102d8abea775f348f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the list of coordinates are in clockwise order.  <a href="_polygon_8cpp.html#a4f5576f119ecbff102d8abea775f348f">More...</a><br /></td></tr>
<tr class="separator:a4f5576f119ecbff102d8abea775f348f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99c7dae2d2fc09893b14b600b930107"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="struct_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_polygon_8cpp.html#ae99c7dae2d2fc09893b14b600b930107">pathTo</a> (const <a class="el" href="struct_coord.html">Coord</a> &amp;point1, const <a class="el" href="struct_coord.html">Coord</a> &amp;point2, const <a class="el" href="struct_polygon.html">Polygon</a> &amp;boundary)</td></tr>
<tr class="memdesc:ae99c7dae2d2fc09893b14b600b930107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a path from one point to another that does not intersect the boundary polygon. Assumes both points are inside the boundary polygon.  <a href="_polygon_8cpp.html#ae99c7dae2d2fc09893b14b600b930107">More...</a><br /></td></tr>
<tr class="separator:ae99c7dae2d2fc09893b14b600b930107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5889b818cf687a090fd7ea612e3ca9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_polygon_8cpp.html#aed5889b818cf687a090fd7ea612e3ca9">naiveTraverse</a> (const <a class="el" href="struct_polygon.html">Polygon</a> &amp;p, std::list&lt; <a class="el" href="struct_edge.html">Edge</a> &gt; &amp;waypoints)</td></tr>
<tr class="memdesc:aed5889b818cf687a090fd7ea612e3ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the polygon using a simple parallel traversal.  <a href="_polygon_8cpp.html#aed5889b818cf687a090fd7ea612e3ca9">More...</a><br /></td></tr>
<tr class="separator:aed5889b818cf687a090fd7ea612e3ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee1ad2cddb1a77491abcba8e02f9738"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="struct_coord.html">Coord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_polygon_8cpp.html#acee1ad2cddb1a77491abcba8e02f9738">naivePath</a> (const <a class="el" href="struct_polygon.html">Polygon</a> &amp;p)</td></tr>
<tr class="memdesc:acee1ad2cddb1a77491abcba8e02f9738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a search path for a polygon using naive traversal.  <a href="_polygon_8cpp.html#acee1ad2cddb1a77491abcba8e02f9738">More...</a><br /></td></tr>
<tr class="separator:acee1ad2cddb1a77491abcba8e02f9738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e61b0c58014a65cc50282908d52954b"><td class="memItemLeft" align="right" valign="top"><a id="a1e61b0c58014a65cc50282908d52954b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pathToHelp</b> (std::list&lt; <a class="el" href="struct_coord.html">Coord</a> &gt; &amp;path, std::list&lt; <a class="el" href="struct_coord.html">Coord</a> &gt;::iterator point1, std::list&lt; <a class="el" href="struct_coord.html">Coord</a> &gt;::iterator point2, const <a class="el" href="struct_polygon.html">Polygon</a> &amp;boundary)</td></tr>
<tr class="separator:a1e61b0c58014a65cc50282908d52954b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="struct_polygon.html" title="Represents a polygon as a list of vertices in CCW order.">Polygon</a> decomposition and traversal algorithm structs and functions. Implements the greedy recursive approach using minimum width sum outlined in a paper by Yan Li et al. All units are in meters. </p>
<dl class="section author"><dt>Author</dt><dd>Harvey Lin </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a12c2040f25d8e3a7b9e1c2024c618cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c2040f25d8e3a7b9e1c2024c618cb6">&#9670;&nbsp;</a></span>INF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INF&#160;&#160;&#160;1000000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An effective infinity that will not overflow the float type. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_config_8h.html#a25d00a4a2950431bf70b51adcc7cb430">float_type</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4f5576f119ecbff102d8abea775f348f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f5576f119ecbff102d8abea775f348f">&#9670;&nbsp;</a></span>clockwise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool clockwise </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_coord.html">Coord</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the list of coordinates are in clockwise order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the list of coordinates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if coordinates are clockwise, else false </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_coord.html" title="Simple representation of a 2D coordinate.">Coord</a> </dd></dl>

</div>
</div>
<a id="ad03f8a8cabc1677521129dd892c0c8f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03f8a8cabc1677521129dd892c0c8f9">&#9670;&nbsp;</a></span>computeGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void computeGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_graph.html">Graph</a>&lt; <a class="el" href="struct_node.html">Node</a>, <a class="el" href="_config_8h.html#a25d00a4a2950431bf70b51adcc7cb430">float_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to compute the adjacencies and weights of the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>the graph to compute </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_graph.html" title="A simple weighted directed graph.">Graph</a> </dd></dl>

</div>
</div>
<a id="a32400b851831f6e0cd8f1f52ba98fc5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32400b851831f6e0cd8f1f52ba98fc5e">&#9670;&nbsp;</a></span>computeStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void computeStates </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_graph.html">Graph</a>&lt; <a class="el" href="struct_node.html">Node</a>, <a class="el" href="_config_8h.html#a25d00a4a2950431bf70b51adcc7cb430">float_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the start states of each node along the traversal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the traversal </td></tr>
    <tr><td class="paramname">g</td><td>the weighted graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_polygon_8cpp.html#a5d74787dedbc4e11c1ab15bf487e61f8" title="State representing which vertex we start the path from. START_V1 = start at vertex 1 of starting edge...">State</a> </dd></dl>

</div>
</div>
<a id="a8e70bd36f60e1f3203b1199882b452b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e70bd36f60e1f3203b1199882b452b1">&#9670;&nbsp;</a></span>cross()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_config_8h.html#a25d00a4a2950431bf70b51adcc7cb430">float_type</a> cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the cross product of two vectors represented as coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c1</td><td>the first vector as a coordinate </td></tr>
    <tr><td class="paramname">c2</td><td>the second vector as a coordinate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the cross product </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_coord.html" title="Simple representation of a 2D coordinate.">Coord</a> <a class="el" href="_config_8h.html#a25d00a4a2950431bf70b51adcc7cb430">float_type</a> </dd></dl>

</div>
</div>
<a id="a5d7e7e0da2580bb7f44c59b8bc711ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7e7e0da2580bb7f44c59b8bc711ebe">&#9670;&nbsp;</a></span>decompose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decompose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; <a class="el" href="struct_polygon.html">Polygon</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompose a concave polygon into multiple convex polygons. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the polygon </td></tr>
    <tr><td class="paramname">l</td><td>stores the resulting list of polygons </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting polygons are stored in l </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_polygon.html" title="Represents a polygon as a list of vertices in CCW order.">Polygon</a> </dd></dl>

</div>
</div>
<a id="af42102455a1869c5308619ec870c161b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42102455a1869c5308619ec870c161b">&#9670;&nbsp;</a></span>distance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_config_8h.html#a25d00a4a2950431bf70b51adcc7cb430">float_type</a> distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_edge.html">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the distance between a vertex and an edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the vertex </td></tr>
    <tr><td class="paramname">e</td><td>the edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance between the vertex and edge </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_coord.html" title="Simple representation of a 2D coordinate.">Coord</a> <a class="el" href="struct_edge.html" title="Simple representation of an edge.">Edge</a> <a class="el" href="_config_8h.html#a25d00a4a2950431bf70b51adcc7cb430">float_type</a> </dd></dl>

</div>
</div>
<a id="a95a2b3b474c41d8c0cb3b9dcef55da51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a2b3b474c41d8c0cb3b9dcef55da51">&#9670;&nbsp;</a></span>distance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_config_8h.html#a25d00a4a2950431bf70b51adcc7cb430">float_type</a> distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the distance between two vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>the first vertex </td></tr>
    <tr><td class="paramname">v2</td><td>the second vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance between the two vertices </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_coord.html" title="Simple representation of a 2D coordinate.">Coord</a> <a class="el" href="_config_8h.html#a25d00a4a2950431bf70b51adcc7cb430">float_type</a> </dd></dl>

</div>
</div>
<a id="a52c0488ba30bc2473cdea0033bb208aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c0488ba30bc2473cdea0033bb208aa">&#9670;&nbsp;</a></span>getWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_span.html">Span</a> getWidth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the width of a convex polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the polygon </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the width of the polygon as a span </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_span.html" title="Representation of a span in Vertex-Edge form.">Span</a> <a class="el" href="struct_polygon.html" title="Represents a polygon as a list of vertices in CCW order.">Polygon</a> </dd></dl>

</div>
</div>
<a id="adc544bfbb4b347cf1ee76da14ab71919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc544bfbb4b347cf1ee76da14ab71919">&#9670;&nbsp;</a></span>intersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_edge.html">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_edge.html">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>intersect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the intersection of two line segments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e1</td><td>the first line segment as an edge </td></tr>
    <tr><td class="paramname">e2</td><td>the second line segment as an edge </td></tr>
    <tr><td class="paramname">intersect</td><td>stores the intersection if one exists </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns true and stores result in intersect if intersection exists, else returns false </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_coord.html" title="Simple representation of a 2D coordinate.">Coord</a> <a class="el" href="struct_edge.html" title="Simple representation of an edge.">Edge</a> </dd></dl>

</div>
</div>
<a id="aba208fdf3e27f0a340f19037e1170627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba208fdf3e27f0a340f19037e1170627">&#9670;&nbsp;</a></span>isConcave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isConcave </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a given vertex of a polygon is concave. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the polygon </td></tr>
    <tr><td class="paramname">i</td><td>index of the vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the vertex is concave, else false </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_polygon.html" title="Represents a polygon as a list of vertices in CCW order.">Polygon</a> </dd></dl>

</div>
</div>
<a id="abd8d432590706d11d55e8be081c39fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8d432590706d11d55e8be081c39fa4">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_polygon.html">Polygon</a> merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge two polygons by their shared edge given the edge's index in each polygon and return the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>the first polygon </td></tr>
    <tr><td class="paramname">p2</td><td>the second polygon </td></tr>
    <tr><td class="paramname">i</td><td>index of the shared edge in p1 </td></tr>
    <tr><td class="paramname">j</td><td>index of the shared edge in p2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the merged polygon </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_polygon.html" title="Represents a polygon as a list of vertices in CCW order.">Polygon</a> </dd></dl>

</div>
</div>
<a id="a5e30299d43abe13ee0c892472f3e3fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e30299d43abe13ee0c892472f3e3fae">&#9670;&nbsp;</a></span>mergeSubregions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mergeSubregions </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; <a class="el" href="struct_polygon.html">Polygon</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine applicable subregions after decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>list of decomposed polygon subregions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_polygon.html" title="Represents a polygon as a list of vertices in CCW order.">Polygon</a> <a class="el" href="_polygon_8cpp.html#a5d7e7e0da2580bb7f44c59b8bc711ebe" title="Decompose a concave polygon into multiple convex polygons.">decompose</a> </dd></dl>

</div>
</div>
<a id="a32585f07b1ef2d1350a3c87da3020097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32585f07b1ef2d1350a3c87da3020097">&#9670;&nbsp;</a></span>minTraversal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; unsigned int &gt; minTraversal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_graph.html">Graph</a>&lt; <a class="el" href="struct_node.html">Node</a>, <a class="el" href="_config_8h.html#a25d00a4a2950431bf70b51adcc7cb430">float_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the minimum cost traversal for the weighted graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>the weighted graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum cost traversal as a list of node indeces </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_graph.html" title="A simple weighted directed graph.">Graph</a> </dd></dl>

</div>
</div>
<a id="acee1ad2cddb1a77491abcba8e02f9738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee1ad2cddb1a77491abcba8e02f9738">&#9670;&nbsp;</a></span>naivePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; <a class="el" href="struct_coord.html">Coord</a> &gt; naivePath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a search path for a polygon using naive traversal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the polygon </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the search path as a list of Coords </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_coord.html" title="Simple representation of a 2D coordinate.">Coord</a> <a class="el" href="struct_polygon.html" title="Represents a polygon as a list of vertices in CCW order.">Polygon</a> <a class="el" href="_polygon_8cpp.html#aed5889b818cf687a090fd7ea612e3ca9" title="Traverse the polygon using a simple parallel traversal.">naiveTraverse</a> </dd></dl>

</div>
</div>
<a id="aed5889b818cf687a090fd7ea612e3ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5889b818cf687a090fd7ea612e3ca9">&#9670;&nbsp;</a></span>naiveTraverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void naiveTraverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; <a class="el" href="struct_edge.html">Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>waypoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse the polygon using a simple parallel traversal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the polygon </td></tr>
    <tr><td class="paramname">waypoints</td><td>stores the resulting waypoints of the traversal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting traversal is stored in waypoints </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_polygon.html" title="Represents a polygon as a list of vertices in CCW order.">Polygon</a> <a class="el" href="struct_edge.html" title="Simple representation of an edge.">Edge</a> </dd></dl>

</div>
</div>
<a id="ae99c7dae2d2fc09893b14b600b930107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99c7dae2d2fc09893b14b600b930107">&#9670;&nbsp;</a></span>pathTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; <a class="el" href="struct_coord.html">Coord</a> &gt; pathTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_coord.html">Coord</a> &amp;&#160;</td>
          <td class="paramname"><em>point2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>boundary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a path from one point to another that does not intersect the boundary polygon. Assumes both points are inside the boundary polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point1</td><td>the first point </td></tr>
    <tr><td class="paramname">point2</td><td>the second point </td></tr>
    <tr><td class="paramname">boundary</td><td>the boundary polygon </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the path as a list of Coords </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_coord.html" title="Simple representation of a 2D coordinate.">Coord</a> <a class="el" href="struct_polygon.html" title="Represents a polygon as a list of vertices in CCW order.">Polygon</a> </dd></dl>

</div>
</div>
<a id="a79821244b87f1fef961a2665b18181f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79821244b87f1fef961a2665b18181f9">&#9670;&nbsp;</a></span>searchPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; <a class="el" href="struct_coord.html">Coord</a> &gt; searchPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the search path for a polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the polygon </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the search path as a list of Coords </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_coord.html" title="Simple representation of a 2D coordinate.">Coord</a> </dd></dl>

</div>
</div>
<a id="ac751ca91c162e32134a7878cf1978a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac751ca91c162e32134a7878cf1978a1e">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a polygon into two along an edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the polygon </td></tr>
    <tr><td class="paramname">v1</td><td>first vertex of edge </td></tr>
    <tr><td class="paramname">v2</td><td>second vertex of edge </td></tr>
    <tr><td class="paramname">p1</td><td>stores the first resulting polygon </td></tr>
    <tr><td class="paramname">p2</td><td>stores the second resulting polygon </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting polygons are stored in p1 and p2 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_polygon.html" title="Represents a polygon as a list of vertices in CCW order.">Polygon</a> </dd></dl>

</div>
</div>
<a id="ab8599468fedd0f0707a9fa58b422beab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8599468fedd0f0707a9fa58b422beab">&#9670;&nbsp;</a></span>traversalLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_config_8h.html#a25d00a4a2950431bf70b51adcc7cb430">float_type</a> traversalLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_graph.html">Graph</a>&lt; <a class="el" href="struct_node.html">Node</a>, <a class="el" href="_config_8h.html#a25d00a4a2950431bf70b51adcc7cb430">float_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the total length of a graph traversal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>the weighted graph </td></tr>
    <tr><td class="paramname">path</td><td>the traversal path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total length of the traversal </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_graph.html" title="A simple weighted directed graph.">Graph</a> <a class="el" href="_config_8h.html#a25d00a4a2950431bf70b51adcc7cb430">float_type</a> </dd></dl>

</div>
</div>
<a id="a501f5a6e2cabc73bdc4bfa3340383d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a501f5a6e2cabc73bdc4bfa3340383d78">&#9670;&nbsp;</a></span>traverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void traverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; <a class="el" href="struct_edge.html">Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>waypoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse a convex polygon and store the waypoints in a list as Edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the polygon to traverse </td></tr>
    <tr><td class="paramname">waypoints</td><td>list to store the traversal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_polygon.html" title="Represents a polygon as a list of vertices in CCW order.">Polygon</a> <a class="el" href="struct_edge.html" title="Simple representation of an edge.">Edge</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
